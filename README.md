# ИДЗ №3 Вариант 15
## Амирханов Никита Русланович БПИ219

### Условия
Разработать программу, вычисляющую с помощью степенного ряда
с точностью не хуже 0,05% значение функции гиперболического
косинуса ch(x) = (e^x + e^−x)/2 для заданного параметра x.

### Задание решено на 10 баллов.
 - Есть исходный код на си, скомпилированный с разными опциями, шаги рефакторинга ассемблероного кода пропущены т.к. писалась программа на ассемблере с нуля.
 - Есть сравнительные тесты показывающие скорость работы обоих программ.
 - Есть генератор случайных чисел с указанием границ
 - Есть ввод-вывод из файла
 - Есть измерение времени работы программы
 - Есть текст программы на языке ассемблера без использования си функций
 - Весь ассемблерный код содержит поясняющие комментарии

### Структура папок
 - `/asm` содержит исходный код на ассембеле без использования си функций
 - `/asm/lib` содержит файлы с дополнительными функциями
 - - `array.s` - работа с массивами
 - - `io.s` - ввод/вывод из консоли/файлов
 - - `str.s` - работа со строками
 - - `time.s` - замер времени
 - - `rand.s` - генерация случайных чисел
 - - `math.s` - некоторые математические функции
 - `/asm/main.s` - главный файл программы
 - `/c-stuff` содержит исходный код на языке си и результаты его компиляции
 - `/tests` папка с тестами

### Запуск ассемблерного кода
```sh
make compile    ; компилирует все дополнительные библиотеки
make build      ; компилирует основой код с добавлением библиотек
```
Далее, чтобы выполнить просто `./main`. Для работы с консолью необходимо указать флаг `-c`. Для ввода и вывода в файл необходимо укзазать флаг `-f` и 2 аргумента `./main -f <input_file> <output_file>`. Для работы с генератором случайных чисел необходимо набрать `./main -r <lower> <upper>`. В таком случае на экран будет выведено сгенерированное значение x. Ограничение на число X: `[-6;6]`. При вводе большего числа будет выведено предупреждение. При значениях за этим диапазоном не гарантируется точность в 0.05%.

### Запуск си кода
```sh
gcc main.c -o main
```
В си программе отсутствует ручной ввод вывод. В остальном используются те же аргументы и их ограничения.

### Важно
 - В любом режиме вывода будут выводиться промежуточные шаги работы программы.
 - Точность программы ограничена 20 итерациями. Значения выше вызывают переполнение из-за факториала.
 - Точность выводимых и вводимых чисел - 16 знаков после запятой. При привышении этого значения не гарантируется верный ответ
 - При вводе из файла обе программы зацикливают выполненние главной функции на 10000000 итераций
 - Файл для ввода числа должен содержать перенос строки в конце
 - Пример файла для ввода числа
```
4.2

```

### Работа с рандомайзером
В обоих случая надо при запуске указать параметры. Пример:
```sh
$ ./main -r -6 6
Generated x value: 2.0000000000000000
Delta: 1.0000000000000000   Value: 1.0000000000000000
Delta: 2.0000000000000000   Value: 3.0000000000000000
Delta: 0.6666666666666665   Value: 3.6666666666666665
Delta: 0.0888888888888890   Value: 3.7555555555555555
Delta: 0.0063492063492063   Value: 3.7619047619047619
Delta: 0.0002821869488536   Value: 3.7621869488536155
Delta: 0.0000085511196621   Value: 3.7621954999732776
Delta: 0.0000001879366960   Value: 3.7621956879099736
Delta: 0.0000000031322784   Value: 3.7621956910422520
Delta: 0.0000000000409450   Value: 3.7621956910831971
Value of ch(x) = 3.7621956910831971
```
Выведется сгеренированное значение x и результат работы программы со всеми промежуточными этапами.

### Тестирование ASM
 - Тест где будет найдено значение целого числа `./main -f ../tests/test1.txt out.txt`
 ```
 3
 ```
 Результат
 ```
 10.0676619943162056
 ```
 - Тест где будет найдено значение целого отрицательного числа `./main -f ../tests/test2.txt out.txt`
 ```
 -4
 ```
 Результат
 ```
 27.3082323679658110
 ```
 - Тест где будет найдено значение отрицательного дробного числа `./main -f ../tests/test3.txt out.txt`
 ```
 -1.337
 ```
 Результат
 ```
 2.0351179642219814
 ```
 - Тест где будет найдено значение дробного числа `./main -f ../tests/test4.txt out.txt`
 ```
 .42
 ```
 Результат
 ```
 1.0895041877168452
 ```

### Тестирование C
 - Тест где будет найдено значение целого числа `./main -f ../tests/test1.txt out.txt`
 ```
 3
 ```
 Результат
 ```
 10.0676619943162056
 ```
 - Тест где будет найдено значение целого отрицательного числа `./main -f ../tests/test2.txt out.txt`
 ```
 -4
 ```
 Результат
 ```
 27.3082323679658110
 ```
 - Тест где будет найдено значение отрицательного дробного числа `./main -f ../tests/test3.txt out.txt`
 ```
 -1.337
 ```
 Результат
 ```
 2.0351179642219814
 ```
 - Тест где будет найдено значение дробного числа `./main -f ../tests/test4.txt out.txt`
 ```
 .42
 ```
 Результат
 ```
 1.0895041877168452
 ```

### Вывод тестирования
Результаты работы программ совпадают

### Сравнение прогамм на си и asm
1. Размер исполняемого файла
 - Размер ассемблероного файла сгенерированного из си кода при помощи флагов `-masm=intel -fno-asynchronous-unwind-tables -fno-jump-tables -fno-stack-protector -fno-exceptions -Os` составляет всего 265 строки. А с оптимизацией `-Ofast` 541 строк. В то же время размер самописной программы на ассемблере составляет 382 строк в main файле + 800 строк в вспомогательных файлах. При этом размер исполняемого файла на ассемблере составляет 13K а у программы на си 13K, а с флагом `-Os` тоже 13K.
2. Время работы программ 
 - Тестировалась работа программ написанных на ассемблере, на си, на ассемблероном коде, скомпилированным при помощи флага `-Ofast`, а так же при помощи флага `-Os`.
 - Тест с зацикливанием на 10000000 итераций:
 ```
asm                         c:          -Ofast asm  -Os asm  
--------------------------------------------------------------
Read:          0.20351      | 0.000011  | 0.000010  | 0.000011
Calculations:  9.527589424  | 4.277416  | 3.569731  | 3.355818
Write:         0.75540      | 0.000022  | 0.000021  | 0.000017

 3. Обработка некорректных данных
  - Элементы выходят за диапазон
  - - Программа выводит предупреждение.
  - Указанного файла не существует
  - - Программы выводят сообщение об ошибке.



### Вывод
Компилятор gcc уже в 3-ий раз оказался умнее меня. Скорость работы программы на чистом ассемблере оказалась меньше чем на си с разницей до 2 раз. При этом время на операции ввода и вывода оказалось в среднем в 100000 раз больше (так как во время них у меня происходила конвертация строки в тип double). Размер исполняемого файла на ассемблере оказлся такой же как и у программы на си. При этом, написание когда на ассемблее во много раз дольше.